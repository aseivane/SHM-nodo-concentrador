version: '3'

services:
  nginx:
    container_name: nginxproxy
    image: nginxproxy/nginx-proxy:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock:ro
    networks:
      - my_network

  next-app:
    container_name: frontend
    build:
      context: ./next-app
      dockerfile: prod.Dockerfile
      args:
        ENV_VARIABLE: ${ENV_VARIABLE}
        NEXT_PUBLIC_ENV_VARIABLE: ${NEXT_PUBLIC_ENV_VARIABLE}
    restart: always
    networks:
      my_network:    
        aliases:
          - shm.com
    ports:
      - "3000:3000"
    expose:
      - "3000"
    environment:
      - VIRTUAL_PORT=3000
      - VIRTUAL_HOST="shm.com"
      - VIRTUAL_PATH="/next/"
      - VIRTUAL_DEST="/"

  node-app:
    container_name: backend
    build:
      context: ./node-app
      dockerfile: prod.Dockerfile
      args:
        ENV_VARIABLE: ${ENV_VARIABLE}
    restart: always
    
    networks:
      my_network:
        aliases:
          - backend.local
    
  #busybox:
  #  container_name: busybox
  #  image: busybox:glibc

  #  networks:
  #    my_network:
  #      aliases:
  #        - busybox.local

    

  # Add more containers below (nginx, postgres, etc.)

# Define a network, which allows containers to communicate
# with each other, by using their container name as a hostname
networks:
  my_network:
    external: true
