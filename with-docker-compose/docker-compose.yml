version: '3'

services:
  nginx:
    container_name: nginxproxy
    image: nginxproxy/nginx-proxy:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - /var/run/docker.sock:/tmp/docker.sock:ro
    networks:
      - my_network

  next-app:
    container_name: frontend
    build:
      context: ./next-app
      dockerfile: Dockerfile
      args:
        ENV_VARIABLE: ${ENV_VARIABLE}
        NEXT_PUBLIC_ENV_VARIABLE: ${NEXT_PUBLIC_ENV_VARIABLE}
    restart: always
    networks:
      my_network:    
        aliases:
          - frontend.shm.com
    expose:
      - "3000"
    environment:
      - VIRTUAL_PORT=3000
      - VIRTUAL_HOST=shm.com

  node-app:
    container_name: backend
    build:
      context: ./node-app
      dockerfile: Dockerfile
      args:
        ENV_VARIABLE: ${ENV_VARIABLE}
    restart: always
    expose:
      - "3000"
    networks:
      my_network:
        aliases:
          - backend.shm.com
  
  mosquitto:
    container_name: mosquitto
    build:
      context: ./mosquitto
      args:
        - USER=${USER}
        - GID=${GID}
        - UID=${UID}
    volumes:
      - type: bind
        source: ./mosquitto//config/
        target: /mosquitto/config/
      - type: bind
        source: ./mosquitto/log/
        target: /mosquitto/log/
      - type: volume
        source: data
        target: /mosquitto/data/
    ports:
      - target: 1883
        published: 1883
        protocol: tcp
        mode: host
      - target: 9001
        published: 9001
        protocol: tcp
        mode: host

volumes:
  data:
    name: "mqtt-broker-data"
  #busybox:
  #  container_name: busybox
  #  image: busybox:glibc

  #  networks:
  #    my_network:
  #      aliases:
  #        - busybox.local

    

  # Add more containers below (nginx, postgres, etc.)

# Define a network, which allows containers to communicate
# with each other, by using their container name as a hostname
networks:
  my_network:
    external: true
